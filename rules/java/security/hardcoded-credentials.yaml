rules:
  - id: constant-db-password
    severity: ERROR
    message: >-
      A potential hard-coded password was identified in a database connection string.
      Passwords should not be stored directly in code but loaded from secure vault.
    metadata:
      cwe: CWE-259
      short-description: Use of hard-coded DB password
      full-description: |-
        A potential hard-coded password was identified in a database connection string.
        Passwords should not be stored directly in code
        but loaded from secure locations such as a Key Management System (KMS).

        The purpose of using a Key Management System is so access can be audited and keys easily rotated
        in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
        when or if, a key is compromised.

        The recommendation on which KMS to use depends on the environment the application is running in:

        - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
        - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
        - For on premise or other alternatives to cloud providers, consider [Hashicorp's
        Vault](https://www.vaultproject.io/)
        - For other cloud providers, please see their documentation
      provenance: https://gitlab.com/gitlab-org/security-products/sast-rules/-/blob/main/java/password/rule-ConstantDBPassword.yml
    languages:
      - java
    patterns:
      - pattern: java.sql.DriverManager.getConnection($URI, $USR, "...");

  - id: java-empty-db-password
    severity: ERROR
    message: >-
      The application does not provide authentication when communicating a database
      server. It is strongly recommended that the database server be configured with
      authentication and restrict what queries users can execute.
    metadata:
      cwe: CWE-306
      short-description: Missing authentication for database
      full-description: |-
        The application does not provide authentication when communicating a database
        server. It is strongly recommended that the database server be configured with
        authentication and restrict what queries users can execute.

        Please see your database server's documentation on how to configure a password.

        Additionally, passwords should not be stored directly in code
        but loaded from secure locations such as a Key Management System (KMS).

        The purpose of using a Key Management System is so access can be audited and keys easily rotated
        in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
        when or if, a key is compromised.

        The recommendation on which KMS to use depends on the environment the application is running in:

        - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
        - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
        - For on premise or other alternatives to cloud providers, consider [Hashicorp's
        Vault](https://www.vaultproject.io/)
        - For other cloud providers, please see their documentation
      provenance: https://gitlab.com/gitlab-org/security-products/sast-rules/-/blob/main/java/password/rule-EmptyDBPassword.yml
    languages:
      - java
    patterns:
      - pattern: java.sql.DriverManager.getConnection($URI, $USR, "");

  - id: hardcoded-password
    severity: ERROR
    message: |
      A potential hard-coded password was identified in a hard-coded string.
      Passwords should not be stored directly in code but loaded from secure vault.
    metadata:
      cwe: CWE-259
      short-description: Use of hard-coded password
      full-description: |-
        A potential hard-coded password was identified in a hard-coded string.
        Passwords should not be stored directly in code
        but loaded from secure locations such as a Key Management System (KMS).

        The purpose of using a Key Management System is so access can be audited and keys easily
        rotated
        in the event of a breach. By hardcoding passwords, it will be extremely difficult to determine
        when or if, a key is compromised.

        The recommendation on which KMS to use depends on the environment the application is running
        in:

        - For Google Cloud Platform consider [Cloud Key Management](https://cloud.google.com/kms/docs)
        - For Amazon Web Services consider [AWS Key Management](https://aws.amazon.com/kms/)
        - For on premise or other alternatives to cloud providers, consider [Hashicorp's
        Vault](https://www.vaultproject.io/)
        - For other cloud providers, please see their documentation
      provenance: https://gitlab.com/gitlab-org/security-products/sast-rules/-/blob/main/java/password/rule-HardcodePassword.yml
    languages:
      - java
    pattern-either:
      - pattern: new java.security.KeyStore.PasswordProtection("...".toCharArray())
      - pattern: java.security.KeyStore.getInstance(...).load(..., "...".toCharArray())
      - pattern: (java.security.KeyStore $KS).load(..., "...".toCharArray())
      - pattern: KeyManagerFactory.getInstance(...).init(..., "...".toCharArray())
      - pattern: (KeyManagerFactory $KMF).init(..., "...".toCharArray())
      - pattern: PBEKeySpec("...", ...)
      - pattern: PasswordAuthentication("...", "...")
      - pattern: (PasswordCallback $CB).setPassword("...")
      - pattern: KerberosKey($_, "...", $_)
      - pattern: java.sql.DriverManager.getConnection($_, $_, "...")
      - pattern: io.vertx.ext.web.handler.CSRFHandler.create(..., "...")
      - pattern: $S.setPassword("...")

  - id: jwt-hardcoded-secret
    severity: WARNING
    message: >-
      A hard-coded credential was detected. It is not recommended to store credentials in source-code,
      as this risks secrets being leaked and used by either an internal or external malicious adversary.
      It is recommended to use environment variables to securely provide credentials or retrieve credentials
      from a secure vault or HSM (Hardware Security Module).
    metadata:
      cwe:
        - CWE-798
      short-description: Use of Hard-coded Credentials
      full-description: |-
        Hardcoding a JSON Web Token (JWT) signing secret in Java source code is a critical security vulnerability. If the code (or compiled artifacts, logs, backups, or configuration snapshots) is ever exposed, an attacker can recover the secret and forge valid JWTs. This allows them to impersonate users, escalate privileges, bypass authentication and authorization checks, and maintain long‑term access because hardcoded secrets are difficult to rotate and are often reused across environments (development, staging, production), increasing overall impact.

        ```java
        // Vulnerable code sample (Java with JJWT)

        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;

        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;

        public class AuthController {

            // Hardcoded JWT secret — vulnerable
            private static final String JWT_SECRET = "my-super-secret-key-123"; // Do NOT hardcode secrets

            public void login(String username, HttpServletResponse response) throws IOException {
                // Normally you would validate the username/password first

                String token = Jwts.builder()
                        .setSubject(username)
                        .signWith(SignatureAlgorithm.HS256, JWT_SECRET) // Anyone with JWT_SECRET can forge tokens
                        .compact();

                response.getWriter().write(token);
            }
        }
        ```

        To remediate this issue, never embed JWT signing keys directly in Java source code, configuration files committed to version control, or client-side code. Instead:

        - Store the JWT secret in a secure secret-management solution (e.g., cloud KMS, HashiCorp Vault, AWS Secrets Manager, GCP Secret Manager) or at minimum inject it as an environment variable managed by your deployment platform.
        - Use different secrets per environment (dev/test/prod) and define a rotation process.
        - Enforce minimum strength (length/entropy) for the secret and short token lifetimes to reduce impact of compromise.
        - Fail fast at startup if the secret is missing or invalid.

        Example using an environment variable and basic validation:

        ```java
        // Safer code sample (Java with JJWT)

        import io.jsonwebtoken.Jwts;
        import io.jsonwebtoken.SignatureAlgorithm;
        import io.jsonwebtoken.security.Keys;

        import javax.crypto.SecretKey;
        import javax.servlet.http.HttpServletResponse;
        import java.io.IOException;
        import java.nio.charset.StandardCharsets;

        public class SecureAuthController {

            // Load secret from environment or secret manager (injected at deploy time)
            private static final String RAW_SECRET = System.getenv("JWT_SECRET");

            // Initialize a strong key from the secret
            private static final SecretKey JWT_KEY = initKey();

            private static SecretKey initKey() {
                if (RAW_SECRET == null || RAW_SECRET.length() < 32) {
                    // Fail fast: configuration error
                    throw new IllegalStateException("JWT_SECRET is not set or is too weak");
                }
                // For HS256, use at least 256 bits (32+ chars of high entropy)
                return Keys.hmacShaKeyFor(RAW_SECRET.getBytes(StandardCharsets.UTF_8));
            }

            public void login(String username, HttpServletResponse response) throws IOException {
                String token = Jwts.builder()
                        .setSubject(username)
                        .signWith(JWT_KEY, SignatureAlgorithm.HS256)
                        .compact();

                response.getWriter().write(token);
            }
        }
        ```
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html
        - https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html
      provenance: https://github.com/semgrep/semgrep-rules/blob/develop/java/java-jwt/security/jwt-hardcode.yaml
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              (Algorithm $ALG) = $ALGO.$HMAC("...");
          - pattern: |
              (io.jsonwebtoken.JwtBuilder $BUILDER).signWith((io.jsonwebtoken.SignatureAlgorithm $ALG), "...");
      - metavariable-regex:
          metavariable: $HMAC
          regex: (HMAC384|HMAC256|HMAC512)

  - id: hardcoded-cryptographic-key
    options:
      disabled: Disabled until array constant initializers are implemented.
    severity: ERROR
    message: |
      Cryptographic keys should not be kept in the source code. The source code can be widely shared
      in an enterprise environment, and is certainly shared in open source. To be managed safely,
      passwords and secret keys should be stored in separate configuration files or keystores.
    metadata:
      cwe: CWE-321
      short-description: Hardcoded cryptographic key
      full-description: |-
        Hardcoding cryptographic keys in source code makes them effectively public: anyone with the code or compiled binaries can extract the key and decrypt or forge data. It also makes rotation hard and often violates security policies.

        ### Insecure example (hardcoded AES key)

        ```java
        import javax.crypto.Cipher;
        import javax.crypto.spec.SecretKeySpec;

        public class InsecureCrypto {
            // Key is hardcoded into the binary and source control
            private static final byte[] AES_KEY_BYTES = new byte[] {
                0x01, 0x23, 0x45, 0x67,
                (byte) 0x89, (byte) 0xAB,
                (byte) 0xCD, (byte) 0xEF,
                0x10, 0x32, 0x54, 0x76,
                (byte) 0x98, (byte) 0xBA,
                (byte) 0xDC, (byte) 0xFE
            };

            public byte[] encrypt(byte[] plaintext) throws Exception {
                SecretKeySpec key = new SecretKeySpec(AES_KEY_BYTES, "AES"); // hardcoded key
                Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
                cipher.init(Cipher.ENCRYPT_MODE, key);
                return cipher.doFinal(plaintext);
            }
        }
        ```

        Problems:

        - The key is stored in the repository and all builds; tools like `javap` can easily recover it from the class file.
        - Rotating the key requires code changes, rebuilds, and redeployment.
        - Any leak of the source or artifact permanently compromises all data encrypted with this key.

        ### Better approach (key loaded from configuration)

        ```java
        import javax.crypto.Cipher;
        import javax.crypto.spec.SecretKeySpec;
        import java.util.Base64;

        public class SaferCrypto {

            public byte[] encrypt(byte[] plaintext) throws Exception {
                String keyB64 = System.getenv("APP_AES_KEY");      // not in code
                byte[] keyBytes = Base64.getDecoder().decode(keyB64);
                SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
                Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
                cipher.init(Cipher.ENCRYPT_MODE, key);
                return cipher.doFinal(plaintext);
            }
        }
        ```

        Here the key is externalized (e.g., environment variable, keystore, KMS), so it is not embedded in source or binaries and can be rotated without code changes.
      provenance: https://semgrep.dev/r/gitlab.find_sec_bugs.HARD_CODE_KEY-1
    languages:
      - java
    pattern-either:
      - patterns:
          - pattern-not-inside: |
              $FUNC(...,byte[] $KEY_BYTES, ...) {
                  ...
              }
          - pattern-either:
              - pattern: new DESKeySpec((byte[] $KEY_BYTES));
              - pattern: new DESedeKeySpec((byte[] $KEY_BYTES));
              - pattern: new KerberosKey(..., (byte[] $KEY_BYTES), ..., ...);
              - pattern: new SecretKeySpec((byte[] $KEY_BYTES), ...);
              - pattern: new X509EncodedKeySpec((byte[] $KEY_BYTES));
              - pattern: new PKCS8EncodedKeySpec((byte[] $KEY_BYTES));
              - pattern: new KeyRep(...,(byte[] $KEY_BYTES));
              - pattern: new KerberosTicket(...,(byte[] $KEY_BYTES),...);
          - metavariable-pattern:
              metavariable: $KEY_BYTES
              patterns:
                - pattern-not-regex: (null)
      - patterns:
          - pattern-not-inside: |
              $FUNC(..., BigInteger $PRIVATE_KEY, ...) {
                  ...
              }
          - pattern-either:
              - pattern: new DSAPrivateKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new DSAPublicKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new DHPrivateKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new DHPublicKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new ECPrivateKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new RSAPrivateKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new RSAMultiPrimePrivateCrtKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new RSAPrivateCrtKeySpec((BigInteger $PRIVATE_KEY), ...);
              - pattern: new RSAPublicKeySpec((BigInteger $PRIVATE_KEY), ...);
          - metavariable-pattern:
              metavariable: $PRIVATE_KEY
              patterns:
                - pattern-not-regex: (null)
