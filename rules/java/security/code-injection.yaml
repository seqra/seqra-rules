rules:
  - id: groovy-injection-in-servlet-app
    severity: ERROR
    message: >-
      Potential code injection: Groovy invocation with user-controlled input.
    metadata:
      cwe:
        - CWE-94
      short-description: Found Groovy invocation with user-controlled input
      full-description: |-
        Groovy injection is a code-injection vulnerability that arises when untrusted input
        is used to build and execute Groovy code at runtime
        (for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).
        If an attacker can control any part of the Groovy script string, they may execute
        arbitrary Groovy/Java code with the application's privileges, leading to full server compromise,
        data exfiltration, or lateral movement.

        Example (vulnerable):
        ```
        String script = request.getParameter("script"); // user-controlled
        GroovyShell shell = new GroovyShell();
        Object result = shell.evaluate(script);         // RCE: attacker controls code
        ```

        To remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;
        prefer static scripts, fixed command mappings, or other non-code-based configuration.
        If dynamic evaluation is truly required, strictly validate and constrain input
        (for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,
        and use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager.
      references:
        - https://owasp.org/www-community/attacks/Code_Injection
      provenance: https://find-sec-bugs.github.io/bugs.htm#GROOVY_SHELL
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/generic/servlet-untrusted-data-source.yaml#java-servlet-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#dangerous-groovy-shell
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'

  - id: groovy-injection-in-spring-app
    severity: ERROR
    message: >-
      Potential code injection: Groovy invocation with user-controlled input. This is a potential code injection.
    metadata:
      cwe:
        - CWE-94
      short-description: Found Groovy invocation with user-controlled input
      full-description: |-
        Groovy injection is a code-injection vulnerability that arises when untrusted input
        is used to build and execute Groovy code at runtime
        (for example via GroovyShell.evaluate, Eval.me, or a Groovy ScriptEngine).
        If an attacker can control any part of the Groovy script string, they may execute
        arbitrary Groovy/Java code with the application's privileges, leading to full server compromise,
        data exfiltration, or lateral movement.

        Example (vulnerable):
        ```
        String script = request.getParameter("script"); // user-controlled
        GroovyShell shell = new GroovyShell();
        Object result = shell.evaluate(script);         // RCE: attacker controls code
        ```

        To remediate this issue, avoid evaluating dynamically constructed Groovy code whenever possible;
        prefer static scripts, fixed command mappings, or other non—code-based configuration.
        If dynamic evaluation is truly required, strictly validate and constrain input
        (for example, by whitelisting a very limited grammar), avoid concatenating raw user data into scripts,
        and use Groovy sandboxing mechanisms such as SecureASTCustomizer plus a hardened SecurityManager.
      references:
        - https://owasp.org/www-community/attacks/Code_Injection
      provenance: https://find-sec-bugs.github.io/bugs.htm#GROOVY_SHELL
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/spring/untrusted-data-source.yaml#spring-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#dangerous-groovy-shell
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'

  - id: ognl-injection-in-servlet-app
    severity: ERROR
    message: >-
      Potential code injection: OGNL expression construction from user-controlled input.
    metadata:
      cwe:
        - CWE-94
      short-description: OGNL expression construction from user-controlled input
      full-description: |-
        OGNL (Object-Graph Navigation Language) injection is a type of expression-language injection
        vulnerability where untrusted user input is evaluated as an OGNL expression on the server.
        OGNL is powerful and can access object properties, call methods, and instantiate classes;
        when attackers can influence OGNL expressions, they may achieve remote code execution (RCE),
        read or modify sensitive data, or bypass access controls. This vulnerability has historically
        affected frameworks such as Apache Struts 2 that use OGNL for data binding and expression
        evaluation in views and configuration.

        Vulnerable code sample:

        ```java
        import ognl.Ognl;
        import ognl.OgnlContext;

        public class OgnlController {

            public Object evaluateExpression(javax.servlet.http.HttpServletRequest request) throws Exception {
                // Attacker controls the "expr" parameter
                String expr = request.getParameter("expr");

                // Build OGNL context from application objects
                OgnlContext context = new OgnlContext();
                context.put("userService", new UserService());
                context.put("system", java.lang.System.class);

                // VULNERABLE: evaluating untrusted input as an OGNL expression
                Object value = Ognl.getValue(expr, context, context.getRoot());

                return value; // result potentially exposed to the client
            }
        }
        ```

        In a Struts 2 application, a similar problem can occur when user-controllable data ends up
        in OGNL-evaluated attributes (e.g., misconfigured tags, parameters bound directly to OGNL
        expressions in XML or JSPs).

        To remediate this issue, never evaluate OGNL (or any expression language) on untrusted input,
        and ensure the framework is configured and updated to prevent such evaluation paths.

        Key steps:
        - Upgrade to the latest secure version of frameworks using OGNL (e.g., latest Struts 2 with
          all OGNL-related security patches).
        - Disable or restrict dynamic method invocation and other features that expand the OGNL attack surface.
        - Avoid building OGNL expressions from request parameters or any user-controlled data.
        - Use strict input binding/whitelisting for parameters and models rather than generic expression evaluation.
        - Enforce strong input validation and encoding, but do not rely on it alone to secure expression evaluation.

        Safer approach (do not evaluate arbitrary OGNL; map user input to allowed operations):

        ```java
        public class SafeController {

            private final UserService userService = new UserService();

            public Object handleRequest(javax.servlet.http.HttpServletRequest request) {
                String action = request.getParameter("action");

                // Whitelist of allowed actions; no OGNL evaluation
                if ("getProfile".equals(action)) {
                    String userId = request.getParameter("userId");
                    return userService.getProfile(userId);
                } else if ("listUsers".equals(action)) {
                    return userService.listUsers();
                } else {
                    throw new IllegalArgumentException("Unsupported action");
                }
            }
        }
        ```

        In Struts 2, prefer:
        - Standard action properties and setters (no dynamic expressions built from user input).
        - Secure configuration (e.g., `struts2.allowed.action.names`, disabling `dynamicMethodInvocation`,
          using “strict method invocation” and secure tag usage).
      references:
        - https://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation
        - https://owasp.org/www-community/attacks/Expression_Language_Injection
      provenance: https://find-sec-bugs.github.io/bugs.htm#OGNL_INJECTION
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/generic/servlet-untrusted-data-source.yaml#java-servlet-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#ognl-injection-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$INPUT'

  - id: ognl-injection-in-spring-app
    severity: ERROR
    message: >-
      Potential code injeciton: OGNL expression construction from user-controlled input.
    metadata:
      cwe:
        - CWE-94
      short-description: OGNL expression construction from user-controlled input
      full-description: |-
          The Object Graph Navigation Language (OGNL) is an expression language that allows access to
          Java objects and properties stored in an ActionContext. Usage of these low-level
          functions is discouraged because they can effectively execute strings as code, leading to
          remote code execution vulnerabilities. Consider using struts tags when processing
          user-supplied input and templates.

          Much like the Struts security guide recommending to not use raw `${}` EL expressions,
          do not call or use the following OGNL packages with user-supplied input:

          - `com.opensymphony.xwork2.ognl`
          - `com.opensymphony.xwork2.util`
          - `com.opensymphony.xwork2.util.reflection`
          - `org.apache.struts2.util.StrutsUtil`
      references: https://struts.apache.org/security/#do-not-use-incoming-untrusted-user-input-in-forced-expression-evaluation
      provenance: https://find-sec-bugs.github.io/bugs.htm#OGNL_INJECTION
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/spring/untrusted-data-source.yaml#spring-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#ognl-injection-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$INPUT'


  - id: script-engine-injection-in-servlet-app
    severity: ERROR
    message: |
      Potential code injection: ScriptEngine executes user-controled code.
    metadata:
      cwe:
        - CWE-94
      short-description: Injection into javax.script.ScriptEngine
      full-description: |-
        Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a
        Java Scripting Engine (e.g., Nashorn, JavaScript, etc.).
        If attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),
        an attacker can execute arbitrary script code in the context of the application's JVM.
        This can lead to data exfiltration, privilege escalation, or full remote code execution,
        depending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).

        ```java
        // Vulnerable code sample
        import javax.script.ScriptEngine;
        import javax.script.ScriptEngineManager;
        import javax.script.ScriptException;
        import javax.servlet.http.HttpServletRequest;

        public class ScriptEvaluator {

            public Object evaluateExpression(HttpServletRequest request) throws ScriptException {
                // Attacker controls this parameter (e.g., ?expr=...)
                String expr = request.getParameter("expr");

                ScriptEngineManager manager = new ScriptEngineManager();
                ScriptEngine engine = manager.getEngineByName("javascript"); // or "nashorn", "groovy", etc.

                // VULNERABLE: directly evaluates attacker-controlled code
                return engine.eval(expr);
            }
        }
        ```

        To remediate this issue, do not execute untrusted input as script code. Treat user input strictly
        as data, not as instructions. Where scripting is necessary:

        1. **Avoid passing user input into `eval`-like APIs as code.**
          - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated
            expression parser that does not allow arbitrary function calls or access to the underlying JVM.
          - Never let the user control full script bodies, function definitions, or arbitrary expressions
            that the engine will execute.

        2. **Use static scripts and bindings for data.**
          Define the script code in your application (trusted), and pass user input only as variables/bindings:

        ```java
        import javax.script.*;

        public class SafeScriptEvaluator {

            private final ScriptEngine engine;
            private final CompiledScript compiled; // optional, but more efficient and safer pattern

            public SafeScriptEvaluator() throws ScriptException {
                ScriptEngineManager manager = new ScriptEngineManager();
                this.engine = manager.getEngineByName("javascript");

                // Trusted, static script embedded in the application
                String script = "function calculate(a, b) { return a + b; } " +
                                "calculate(a, b);";

                this.compiled = ((Compilable) engine).compile(script);
            }

            public Object safeEvaluate(int a, int b) throws ScriptException {
                Bindings bindings = engine.createBindings();
                bindings.put("a", a);   // user input as data
                bindings.put("b", b);   // user input as data

                // Only the trusted script runs; user data cannot change the code
                return compiled.eval(bindings);
            }
        }
        ```

        3. **Restrict the script engine's capabilities (sandboxing), if supported.**
          - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,
            and network APIs from within the script.
          - Run script engines in a constrained environment (e.g., separate process/container, or with
            appropriate security manager / policy, if available).

        4. **Validate and constrain inputs on a strict allowlist.**
          - If you must accept some form of “expression” from users, define a grammar or a very narrow
            allowed syntax and reject anything outside that set.
          - Do not assume that “it's just math” is safe; enforce it programmatically.
      references:
        - https://owasp.org/www-community/attacks/Code_Injection
      provenance: https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/generic/servlet-untrusted-data-source.yaml#java-servlet-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#dangerous-script-engine-eval
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'

  - id: script-engine-injection-in-spring-app
    severity: ERROR
    message: >-
      Potential code injection: ScriptEngine executes user-controled code.
    metadata:
      cwe:
        - CWE-94
      short-description: Injection into javax.script.ScriptEngine
      full-description: |-
        Injection into `javax.script.ScriptEngine` occurs when untrusted input is evaluated as code by a
        Java Scripting Engine (e.g., Nashorn, JavaScript, etc.).
        If attacker-controlled data is passed directly to `ScriptEngine.eval()` (or similar methods),
        an attacker can execute arbitrary script code in the context of the application's JVM.
        This can lead to data exfiltration, privilege escalation, or full remote code execution,
        depending on what the script engine can access (e.g., Java classes, filesystem, network, environment variables).

        ```java
        // Vulnerable code sample
        import javax.script.ScriptEngine;
        import javax.script.ScriptEngineManager;
        import javax.script.ScriptException;
        import javax.servlet.http.HttpServletRequest;

        public class ScriptEvaluator {

            public Object evaluateExpression(HttpServletRequest request) throws ScriptException {
                // Attacker controls this parameter (e.g., ?expr=...)
                String expr = request.getParameter("expr");

                ScriptEngineManager manager = new ScriptEngineManager();
                ScriptEngine engine = manager.getEngineByName("javascript"); // or "nashorn", "groovy", etc.

                // VULNERABLE: directly evaluates attacker-controlled code
                return engine.eval(expr);
            }
        }
        ```

        To remediate this issue, do not execute untrusted input as script code. Treat user input strictly
        as data, not as instructions. Where scripting is necessary:

        1. **Avoid passing user input into `eval`-like APIs as code.**
          - If you only need to support simple operations (e.g., arithmetic), implement or use a dedicated
            expression parser that does not allow arbitrary function calls or access to the underlying JVM.
          - Never let the user control full script bodies, function definitions, or arbitrary expressions
            that the engine will execute.

        2. **Use static scripts and bindings for data.**
          Define the script code in your application (trusted), and pass user input only as variables/bindings:

        ```java
        import javax.script.*;

        public class SafeScriptEvaluator {

            private final ScriptEngine engine;
            private final CompiledScript compiled; // optional, but more efficient and safer pattern

            public SafeScriptEvaluator() throws ScriptException {
                ScriptEngineManager manager = new ScriptEngineManager();
                this.engine = manager.getEngineByName("javascript");

                // Trusted, static script embedded in the application
                String script = "function calculate(a, b) { return a + b; } " +
                                "calculate(a, b);";

                this.compiled = ((Compilable) engine).compile(script);
            }

            public Object safeEvaluate(int a, int b) throws ScriptException {
                Bindings bindings = engine.createBindings();
                bindings.put("a", a);   // user input as data
                bindings.put("b", b);   // user input as data

                // Only the trusted script runs; user data cannot change the code
                return compiled.eval(bindings);
            }
        }
        ```

        3. **Restrict the script engine's capabilities (sandboxing), if supported.**
          - Disable or strictly limit access to `Java.type`, reflection, file I/O, process execution,
            and network APIs from within the script.
          - Run script engines in a constrained environment (e.g., separate process/container, or with
            appropriate security manager / policy, if available).

        4. **Validate and constrain inputs on a strict allowlist.**
          - If you must accept some form of “expression” from users, define a grammar or a very narrow
            allowed syntax and reject anything outside that set.
          - Do not assume that “it's just math” is safe; enforce it programmatically.
      references:
        - https://owasp.org/www-community/attacks/Code_Injection
      provenance: https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/spring/untrusted-data-source.yaml#spring-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/code-injection-sinks.yaml#dangerous-script-engine-eval
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'

  - id: ssti-in-servlet-app
    severity: ERROR
    message: >-
      Potential template injection: unvalidated user data flows into template engine
    metadata:
      cwe:
        - CWE-94
        - CWE-1336
      short-description: Unvalidated user data flows into template engine
      full-description: |-
        Template engine injection (often called server-side template injection, SSTI) is a
        vulnerability where untrusted input is interpreted as template code by a server-side template engine
        (e.g., FreeMarker, Velocity, Thymeleaf, JSP EL). In Java servlet applications,
        this happens when user-controlled data is used to build or select templates,
        or is otherwise passed to the template engine in a way that allows it to be executed
        rather than treated as plain data. Successful exploitation can lead to information disclosure,
        arbitrary server-side code execution, or full compromise of the application server.

        ```java
        // Vulnerable code sample (Java servlet + FreeMarker)

        import freemarker.template.Configuration;
        import freemarker.template.Template;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.io.StringReader;
        import java.util.HashMap;
        import java.util.Map;

        public class MessageServlet extends HttpServlet {

            @Override
            protected void doPost(HttpServletRequest request, HttpServletResponse response) {
                try {
                    // Attacker controls the entire template content
                    String templateSource = request.getParameter("messageTemplate");

                    Configuration cfg = (Configuration) getServletContext().getAttribute("freemarkerCfg");

                    // VULNERABLE: compiling a template directly from user input
                    Template t = new Template("userTemplate", new StringReader(templateSource), cfg);

                    Map<String, Object> model = new HashMap<>();
                    model.put("username", request.getParameter("username"));

                    response.setContentType("text/html;charset=UTF-8");
                    t.process(model, response.getWriter());  // User input is interpreted as template code
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
        ```

        To remediate this issue, never allow untrusted input to be treated as template code.
        Use only static, server-side—controlled templates and ensure user data is inserted strictly as data (variables),
        not as executable expressions or template fragments. Also, restrict dangerous template features
        (e.g., arbitrary class loading, execution helpers) where possible.

        A safer approach:

        ```java
        // Safer code sample (whitelisted template + data only)

        import freemarker.template.Configuration;
        import freemarker.template.Template;
        import javax.servlet.http.HttpServlet;
        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpServletResponse;
        import java.util.HashMap;
        import java.util.Map;

        public class MessageServlet extends HttpServlet {

            @Override
            protected void doPost(HttpServletRequest request, HttpServletResponse response) {
                try {
                    Configuration cfg = (Configuration) getServletContext().getAttribute("freemarkerCfg");

                    // Use only server-controlled template names (e.g., enum, config, or hard-coded)
                    String templateName = "message.ftl";  // static template stored on the server
                    Template t = cfg.getTemplate(templateName);

                    // Treat user input as plain data only
                    String username = request.getParameter("username");
                    String messageText = request.getParameter("messageText");

                    Map<String, Object> model = new HashMap<>();
                    model.put("username", username);
                    model.put("messageText", messageText);

                    response.setContentType("text/html;charset=UTF-8");
                    t.process(model, response.getWriter());

                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }
        ```

        Additional hardening steps:

        - Do not construct templates or template fragments (e.g., `new Template(...)`, `engine.process(userInput, ...)`)
          from user input, including from HTTP parameters, headers, cookies, or database fields that users can influence.
        - Use strict whitelisting when selecting templates (e.g., map allowed IDs to fixed template filenames).
        - Configure the template engine in a “safe” mode where available (e.g., disable or restrict access to arbitrary
          classes, reflection, or command execution helpers).
        - Validate and, if necessary, HTML-escape user-provided strings before rendering, so they are displayed as
          text rather than interpreted as markup or expressions.
        - Avoid using powerful template engines as general-purpose expression evaluators for user input;
          if evaluation is required, use dedicated, sandboxed expression libraries with strong security guarantees.
      references:
        - https://portswigger.net/web-security/server-side-template-injection
      provenance: https://github.com/github/codeql/tree/cdd8aa49e16650a96b8993e8745c7672600fe930/java/ql/lib/ext
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/generic/servlet-untrusted-data-source.yaml#java-servlet-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/template-injection-sinks.yaml#java-ssti-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'

  - id: ssti-in-spring-app
    severity: ERROR
    message: |
      Potential template injection: unvalidated user data flows into template engine
    metadata:
      cwe:
        - CWE-94
        - CWE-1336
      short-description: Unvalidated user data flows into template engine
      full-description: |-
        Template engine injection (server-side template injection, SSTI) in Spring MVC/Spring Boot applications
        occurs when user-controlled data is interpreted as template or expression code by the view layer or by Spring Expression Language (SpEL).
        In typical Spring apps this happens when untrusted input is used as a template body, fragment, or expression,
        or when SpEL is evaluated on data that comes from the request. Successful exploitation can lead to arbitrary
        server-side code execution, data exfiltration, or full compromise of the application.

        ```java
        // Vulnerable Spring MVC + Thymeleaf example (SSTI via StringTemplateResolver)

        import org.springframework.stereotype.Controller;
        import org.springframework.web.bind.annotation.*;
        import org.thymeleaf.context.Context;
        import org.thymeleaf.spring5.SpringTemplateEngine;

        @Controller
        @RequestMapping("/messages")
        public class MessageController {

            private final SpringTemplateEngine templateEngine;

            public MessageController(SpringTemplateEngine templateEngine) {
                this.templateEngine = templateEngine;
            }

            @PostMapping("/preview")
            @ResponseBody
            public String preview(@RequestParam("template") String template,
                                  @RequestParam("username") String username) {

                // Attacker fully controls "template" request parameter.
                // With a StringTemplateResolver configured, this is treated as a full Thymeleaf template.

                Context ctx = new Context();
                ctx.setVariable("username", username);

                // VULNERABLE: user input is parsed and executed as a Thymeleaf/SpringEL template
                return templateEngine.process(template, ctx);
            }
        }

        // Example of insecure configuration somewhere in @Configuration:

        import org.springframework.context.annotation.Bean;
        import org.springframework.context.annotation.Configuration;
        import org.thymeleaf.templateresolver.StringTemplateResolver;
        import org.thymeleaf.templatemode.TemplateMode;

        @Configuration
        public class ThymeleafConfig {

            @Bean
            public SpringTemplateEngine templateEngine() {
                SpringTemplateEngine engine = new SpringTemplateEngine();
                engine.addTemplateResolver(stringTemplateResolver()); // processes raw strings as templates
                return engine;
            }

            @Bean
            public StringTemplateResolver stringTemplateResolver() {
                StringTemplateResolver resolver = new StringTemplateResolver();
                resolver.setTemplateMode(TemplateMode.HTML);
                resolver.setCacheable(false);
                return resolver;
            }
        }
        ```

        In this example, an attacker can send a payload such as:

        ```text
        [[${T(java.lang.Runtime).getRuntime().exec('id')}]]
        ```

        which, depending on the exact Spring/Thymeleaf/SpEL version and configuration,
        may allow arbitrary command or method execution on the server.

        To remediate this issue, never evaluate or compile templates or expressions directly
        from untrusted input in Spring. Use only server-controlled template names with standard `ViewResolver`s,
        and treat user data strictly as data passed to the model, not as template instructions.

        Safer Spring MVC + Thymeleaf example:

        ```java
        // Safe-ish version: static templates only, user input is data

        import org.springframework.stereotype.Controller;
        import org.springframework.ui.Model;
        import org.springframework.web.bind.annotation.*;

        @Controller
        @RequestMapping("/messages")
        public class MessageController {

            @PostMapping("/preview")
            public String preview(@RequestParam("username") String username,
                                  @RequestParam("messageText") String messageText,
                                  Model model) {

                // Use a fixed, server-side template name only
                String templateName = "messagePreview";  // e.g. src/main/resources/templates/messagePreview.html

                // User input is added as plain data to the model
                model.addAttribute("username", username);
                model.addAttribute("messageText", messageText);

                // The view resolver will select the template based on this fixed name
                return templateName;
            }
        }
        ```

        Key hardening steps in Spring-based applications:

        - Do **not** use `StringTemplateResolver`, `FreeMarkerTemplateUtils.processTemplateIntoString`,
          or similar APIs on untrusted strings. Only process templates that reside on the server and are under your control.
        - Do **not** evaluate SpEL on user input (e.g., via `SpelExpressionParser.parseExpression(userInput)`
          or any dynamic expression features wired to request parameters).
        - Always use fixed or strictly whitelisted view names in controllers (`return "fixedView"`),
          never build view names or fragment expressions from request data.
        - Configure template engines in “safe” modes where possible: restrict method invocation,
          access to arbitrary classes, and reflection in SpEL/OGNL.
        - Escape user-supplied text appropriately in templates (e.g., `th:text` instead of `th:utext` in Thymeleaf)
          to prevent it from being interpreted as HTML/JavaScript.
        - Keep Spring, Thymeleaf, and other template engine libraries up-to-date to benefit from security fixes and safer defaults.
      references:
        - https://portswigger.net/web-security/server-side-template-injection
      provenance: https://github.com/github/codeql/tree/cdd8aa49e16650a96b8993e8745c7672600fe930/java/ql/lib/ext
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/spring/untrusted-data-source.yaml#spring-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/template-injection-sinks.yaml#java-ssti-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'


  - id: el-injection-in-servlet-app
    severity: ERROR
    message: >-
      Potential code injection: calling Java Expression Language method directly with user-supplied input may allow an adversary to
      execute arbitrary Java code, including OS system commands.
    metadata:
      cwe: CWE-917
      short-description: Potential expression language injection
      full-description: |-
        Expression Language (EL) injection in Java occurs when user-controlled input is evaluated as an expression by
        an EL engine (e.g., Java Expression Language, JSP/JSF EL, Spring Expression Language / SpEL).
        Because EL can access object properties, call methods, and sometimes invoke static methods,
        an attacker who controls the expression string can often read sensitive data, manipulate the server-side state,
        or even achieve remote code execution (RCE), depending on the framework and configuration.

        ```java
        // Vulnerable code sample (Java EE / Jakarta EE style EL)

        import jakarta.el.ELContext;
        import jakarta.el.ExpressionFactory;
        import jakarta.el.ValueExpression;
        import jakarta.servlet.http.*;

        public class EvalServlet extends HttpServlet {
            private final ExpressionFactory factory = ExpressionFactory.newInstance();

            @Override
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {
                String expr = request.getParameter("expr"); // e.g. attacker-controlled: "${''.getClass().forName('java.lang.Runtime').getRuntime().exec('id')}"
                ELContext elContext = getServletContext().getELContext(); // simplified for example

                // VULNERABLE: evaluating raw user input as an EL expression
                ValueExpression ve = factory.createValueExpression(elContext, expr, Object.class);
                Object result = ve.getValue(elContext);

                response.getWriter().println("Result: " + result);
            }
        }
        ```

        In this example, the attacker fully controls `expr`. Depending on what the EL implementation allows,
        they may be able to call arbitrary methods, access beans, read environment variables, or execute system commands.

        To remediate this issue, never evaluate user input as an EL/SpEL expression.
        Treat user input strictly as data, not as code or templates. Use static (developer-defined)
        expressions and bind user values as variables/parameters, or avoid EL evaluation entirely for untrusted strings.

        Safer approach (expression is static, user data is just a variable):

        ```java
        import jakarta.el.ELContext;
        import jakarta.el.ExpressionFactory;
        import jakarta.el.ValueExpression;
        import jakarta.servlet.http.*;

        public class SafeServlet extends HttpServlet {
            private final ExpressionFactory factory = ExpressionFactory.newInstance();

            @Override
            protected void doGet(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException {
                String userName = request.getParameter("name"); // untrusted, but only used as data
                if (userName == null) userName = "";

                ELContext elContext = getServletContext().getELContext();
                elContext.getELResolver().setValue(elContext, null, "name", userName);

                // SAFE: expression is hard-coded, attacker cannot change what gets evaluated
                String template = "Hello ${name}";
                ValueExpression ve = factory.createValueExpression(elContext, template, String.class);
                String output = (String) ve.getValue(elContext);

                // Optionally also HTML-encode before output to prevent XSS
                response.getWriter().println(output);
            }
        }
        ```

        Additional remediation steps:

        - **Do not** pass raw user input to `ExpressionFactory.createValueExpression`,
          `SpelExpressionParser.parseExpression`, or similar “evaluate expression” APIs.
        - If you must support some kind of user-defined mini-language, implement a **strict parser/whitelist**
          that only allows safe operations (e.g., numeric operations only, no method calls, no property access).
        - In Spring, prefer `SimpleEvaluationContext` or a custom `EvaluationContext` with:
          - No bean resolver or only a whitelisted bean resolver.
          - Restricted method/property resolvers (disallow reflection, system-level classes, `Runtime`, etc.).
        - Keep frameworks and EL libraries up to date; many EL engines have configuration options or security
          patches that disable or restrict dangerous features.
      references:
        - https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection
        - https://en.wikipedia.org/wiki/Unified_Expression_Language
      provenance: https://gitlab.com/gitlab-org/security-products/sast-rules/-/blob/main/java/inject/rule-ELInjection.yml
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/generic/servlet-untrusted-data-source.yaml#java-servlet-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/generic/command-injection-sinks.yaml#java-expression-language-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$EXPR'

  - id: spring-el-injection
    severity: ERROR
    message: >-
      Potential code injection: calling Spring Expression Language method directly with user-supplied input
      may allow an adversary to  read or modify sensitive data, bypass security checks, or, in severe cases,
      execute arbitrary code within the application's context.
    metadata:
      cwe: CWE-917
      short-description: Potential expression language injection
      full-description: |-
        Spring Expression Language (SpEL) injection is an expression-language injection vulnerability in Spring-based applications. It occurs when untrusted input is directly embedded into, or used as, a SpEL expression and then evaluated. Because SpEL can access bean methods, system properties, and other internal objects, a successful injection can allow an attacker to read or modify sensitive data, bypass security checks, or, in severe cases, execute arbitrary code within the application's context.

        Vulnerable code sample

        ```java
        @RestController
        public class SearchController {
          private final ExpressionParser parser = new SpelExpressionParser();
          private final SearchService searchService = new SearchService();

          @GetMapping("/search")
          public String search(@RequestParam("expr") String exprParam) {
            // VULNERABLE: directly interpreting user input as a SpEL expression
            EvaluationContext context = new StandardEvaluationContext(searchService);
            Expression expression = parser.parseExpression(exprParam);
            Object result = expression.getValue(context);
            return result == null ? "" : result.toString();
          }
        }

        class SearchService {
          public String searchByKeyword(String keyword) {
            // perform a search
            return "Results for: " + keyword;
          }

          public String internalAdminMethod() {
              // not meant to be publicly exposed
              return "Sensitive admin info";
          }
        }
        ```

        In this example, an attacker controls `exprParam` (e.g., via `GET /search?expr=...`) and can craft a SpEL expression that calls methods on `SearchService`, reads internal data, or interacts with other beans accessible through the context.

        To remediate this issue, avoid evaluating user input as SpEL code and strictly separate data from expressions. Never build SpEL expressions by concatenating or directly passing untrusted values to `parseExpression`. Instead:

        1. **Use fixed expressions and bind user input as data (variables or parameters)**
             The expression string should be constant and not influenced by user input; only variable values should come from outside.

        ```java
        @RestController
        public class SafeSearchController {
          private final SearchService searchService = new SearchService();

          @GetMapping("/search")
          public String search(@RequestParam("q") String query) {
            // SAFE: treat query as plain text input, not as SpEL
            return searchService.searchByKeyword(query);
          }
        }
        ```

        If you truly need SpEL for dynamic evaluation, keep the expression static and inject untrusted values only as variables:

        ```java
        ExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression("searchByKeyword(#q)");

        EvaluationContext context = new StandardEvaluationContext(searchService);
        context.setVariable("q", userSuppliedQuery); // value, not code

        Object result = expression.getValue(context); // userSuppliedQuery is data only
        ```

        2. **Use restricted evaluation contexts where possible**
          - Prefer `SimpleEvaluationContext` for read‑only, data-binding scenarios; it disables many powerful SpEL features (like arbitrary method invocation) that increase risk.
          - Limit accessible root objects and properties in the evaluation context to the bare minimum required.

        3. **Avoid dynamic security annotations based on user input**
          For annotations like `@PreAuthorize` or `@PostAuthorize`, use constant expressions and avoid string concatenation with user input:

        ```java
        // Safe usage (constant expression)
        @PreAuthorize("hasRole('ADMIN')")
        public void adminOnlyAction() { ... }

        // Do NOT do this (dynamic SpEL built from user data)
        // @PreAuthorize("@permissionService.hasPermission(authentication, '" + userControlled + "')")
        ```

        4. **Validate and constrain input**
        Where you must accept structured expressions from users (e.g., filters, search languages), define a custom, limited grammar or DSL and parse it yourself. Do not reuse SpEL as a general-purpose query language for untrusted input.
      references:
        - https://owasp.org/www-community/vulnerabilities/Expression_Language_Injection
        - https://en.wikipedia.org/wiki/Unified_Expression_Language
      provenance: https://docs.spring.io/spring-framework/reference/core/expressions.html
    languages:
      - java
    mode: join
    join:
      refs:
        - rule: java/lib/spring/untrusted-data-source.yaml#spring-untrusted-data-source
          as: untrusted-data
        - rule: java/lib/spring/spel-injection-sinks.yaml#spel-injection-sinks
          as: sink
      on:
        - 'untrusted-data.$UNTRUSTED -> sink.$UNTRUSTED'
